#!/bin/bash\n touch $PWD/out.txt\t\necho "3rd option selected, patching pip first" >> out.txt\n# This patch tells the pip program to always trust the needed sites through a global config file. \n# The loading order for config files is as follows:\n# Path specified by the PIP_CONFIG_FILE enviroment variable (couldnt get that to work without root)\n# Global - /Library/Application Support/pip/pip.conf\n# User - $HOME/Library/Application Support/pip/pip.conf OR $HOME/.config/pip/pip.conf\n# Site - $VIRTUAL_ENV/pip.conf\n\n# Here I\'m using the Global method. It would be better to use the PIP_CONFIG_FILE method,\n# however to edit the enviroemtn variables I would need root access. \n# This creates an issue of authentication, meaning I would be unable to portably pack this \n# Application without giving EVERY user some sort of admin role, which is not wise. \nmkdir -p /Library/Application\\ Support/pip &&  printf "%s\\n" "[global]" "trusted-host = pypi.python.org" "               pypi.org" "               files.pythonhosted.org" > /Library/Application\\ Support/pip/pip.conf || echo "Failed to create conf file, please run with root permissions and try again" >> out.txt\necho "Patched pip, attempting anaconda" >> out.txt\n# The way this patch works is it gets the file for ssl certificates, then patches in the\n# woodleigh ssl certs to make sure anaconda doesn\'t think it\'s being attacked by a Man-in-the-middle attack. \n# If woodleigh ever changes its certificates, you can run "generator.sh" and that will generate a new certificate file\nb=.conda.ssl.pem\nc="ssl_verify: $HOME/$b"\na=.continuum/anaconda-client/config.yaml\nmv "$PWD/$b" "$PWD/old_certs/$b" || echo "ha!" >> out.txt\ncurl https://curl.se/ca/cacert.pem -o $PWD/$b\necho quit | openssl s_client -showcerts -servername "curl.haxx.se" -connect curl.haxx.se:443 | pcregrep -M -e "----.*(\\n.*){19}" | pcregrep -M -v -e "---\\nServer certificate" >> $b\ncp $PWD/$b $HOME/$b\n sed -i \'\' "s~ssl_verify: true~$c~" $HOME/$a ||  sed -i \'\' "s~ssl_verify: True~$c~" $HOME/$a\n# Here, not only is sed different on macos than linux or other bash systems, \n# but it also needs the double quotes in order to expand the $b option.\n# You will also notice that i have used \'~\' as the seporator, this is because my variables\n# have slashes in them\necho "Patched Both successfully!" >> out.txt\n
